name: Cross-Platform Build and Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: false
        default: 'latest'
      release_type:
        description: 'Release type'
        required: false
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
  push:
    tags:
      - 'v*'
    branches:
      - main
      - develop
  pull_request:
    branches: [ main, develop ]

env:
  PYTHON_VERSION: '3.11'
  APP_NAME: 'CSC-Reach'

jobs:
  # Job 1: Run tests and quality checks
  test-and-quality:
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
      cache-key: ${{ steps.cache-key.outputs.key }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Generate cache key
      id: cache-key
      run: |
        # Create a comprehensive cache key based on multiple factors
        CACHE_KEY="build-$(date +'%Y-%m')-${{ hashFiles('**/requirements.txt', '**/pyproject.toml', 'scripts/build/**', 'src/**/*.py') }}"
        echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "Generated cache key: $CACHE_KEY"
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Cache build tools
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pyinstaller
          build/cache
        key: ${{ runner.os }}-build-tools-${{ steps.cache-key.outputs.key }}
        restore-keys: |
          ${{ runner.os }}-build-tools-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r requirements.txt
        pip install -e .
        
    - name: Run code quality checks
      run: |
        echo "üîç Running comprehensive code quality checks..."
        
        # Initialize quality check results
        QUALITY_ISSUES=0
        
        # Check code formatting with black
        echo "Checking code formatting..."
        if ! black --check src/ tests/ scripts/; then
          echo "‚ùå Code formatting issues found"
          QUALITY_ISSUES=$((QUALITY_ISSUES + 1))
        else
          echo "‚úÖ Code formatting passed"
        fi
        
        # Run flake8 for linting
        echo "Running linting checks..."
        if ! flake8 src/ tests/ scripts/ --max-line-length=88 --extend-ignore=E203,W503 --statistics; then
          echo "‚ùå Linting issues found"
          QUALITY_ISSUES=$((QUALITY_ISSUES + 1))
        else
          echo "‚úÖ Linting passed"
        fi
        
        # Type checking with mypy
        echo "Running type checks..."
        if ! mypy src/ --ignore-missing-imports --show-error-codes; then
          echo "‚ùå Type checking issues found"
          QUALITY_ISSUES=$((QUALITY_ISSUES + 1))
        else
          echo "‚úÖ Type checking passed"
        fi
        
        # Security checks with bandit
        echo "Running security checks..."
        if ! bandit -r src/ -f json -o bandit-report.json; then
          echo "‚ùå Security issues found"
          QUALITY_ISSUES=$((QUALITY_ISSUES + 1))
        else
          echo "‚úÖ Security checks passed"
        fi
        
        # Import sorting with isort
        echo "Checking import sorting..."
        if ! isort --check-only src/ tests/ scripts/; then
          echo "‚ùå Import sorting issues found"
          QUALITY_ISSUES=$((QUALITY_ISSUES + 1))
        else
          echo "‚úÖ Import sorting passed"
        fi
        
        echo "Quality check summary: $QUALITY_ISSUES issues found"
        
    - name: Run unit tests with coverage
      run: |
        echo "üß™ Running unit tests with coverage..."
        pytest tests/unit/ \
          -v \
          --tb=short \
          --cov=src/multichannel_messaging \
          --cov-report=xml \
          --cov-report=html \
          --cov-report=term-missing \
          --cov-fail-under=80 \
          --junit-xml=unit-test-results.xml
        
    - name: Run integration tests
      run: |
        echo "üîó Running integration tests..."
        pytest tests/integration/ \
          -v \
          --tb=short \
          --junit-xml=integration-test-results.xml
          
    - name: Run GUI tests (if available)
      run: |
        echo "üñ•Ô∏è Running GUI tests..."
        if [ -d "tests/gui" ]; then
          pytest tests/gui/ \
            -v \
            --tb=short \
            --junit-xml=gui-test-results.xml
        else
          echo "No GUI tests found, skipping..."
        fi
        
    - name: Generate test report
      if: always()
      run: |
        echo "üìä Generating comprehensive test report..."
        
        # Create test report directory
        mkdir -p test-reports
        
        # Combine test results
        if command -v junitparser >/dev/null 2>&1; then
          junitparser merge unit-test-results.xml integration-test-results.xml gui-test-results.xml test-reports/combined-results.xml 2>/dev/null || true
        fi
        
        # Generate coverage badge
        if [ -f "coverage.xml" ]; then
          coverage-badge -o test-reports/coverage-badge.svg
        fi
        
        # Create summary report
        cat > test-reports/test-summary.md << EOF
        # Test Execution Summary
        
        **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        
        ## Test Results
        
        - Unit Tests: $(grep -o 'tests="[0-9]*"' unit-test-results.xml 2>/dev/null | grep -o '[0-9]*' || echo "N/A")
        - Integration Tests: $(grep -o 'tests="[0-9]*"' integration-test-results.xml 2>/dev/null | grep -o '[0-9]*' || echo "N/A")
        - GUI Tests: $(grep -o 'tests="[0-9]*"' gui-test-results.xml 2>/dev/null | grep -o '[0-9]*' || echo "N/A")
        
        ## Coverage
        
        $(coverage report --format=markdown 2>/dev/null || echo "Coverage report not available")
        
        ## Quality Checks
        
        - Code Formatting: $([ -f ".black-check" ] && echo "‚úÖ Passed" || echo "‚ùå Failed")
        - Linting: $([ -f ".flake8-check" ] && echo "‚úÖ Passed" || echo "‚ùå Failed")  
        - Type Checking: $([ -f ".mypy-check" ] && echo "‚úÖ Passed" || echo "‚ùå Failed")
        - Security: $([ -f "bandit-report.json" ] && echo "‚úÖ Passed" || echo "‚ùå Failed")
        EOF
        
    - name: Upload test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.sha }}
        path: |
          test-reports/
          htmlcov/
          *.xml
          *.json
          *.html
        retention-days: 30
        
    - name: Run comprehensive test suite
      run: |
        echo "üöÄ Running comprehensive test suite..."
        python scripts/test_runner.py --test-type all --verbose
        
    - name: Check if build should proceed
      id: check
      run: |
        # Check test results and quality gates
        if [ -f "test-reports/comprehensive-test-report-*.json" ]; then
          # Parse test results to determine if build should proceed
          LATEST_REPORT=$(ls -t test-reports/comprehensive-test-report-*.json | head -n1)
          OVERALL_PASSED=$(python -c "import json; data=json.load(open('$LATEST_REPORT')); print(data['summary']['overall_passed'])")
          
          if [ "$OVERALL_PASSED" = "True" ]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ All tests passed, proceeding with build"
          else
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "‚ùå Tests failed, skipping build"
            
            # Still allow build for development branches
            if [[ "${{ github.ref_name }}" == "develop" || "${{ github.ref_name }}" == "feature/"* ]]; then
              echo "should-build=true" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Allowing build for development branch despite test failures"
            fi
          fi
        else
          echo "should-build=true" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è No test results found, proceeding with build"
        fi

  # Job 2: Build Windows executable
  build-windows:
    needs: test-and-quality
    if: needs.test-and-quality.outputs.should-build == 'true'
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~\AppData\Local\pip\Cache
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Cache PyInstaller build cache
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Local\pyinstaller
          build\cache
          build\temp
        key: ${{ runner.os }}-pyinstaller-${{ needs.test-and-quality.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-pyinstaller-
          
    - name: Cache build artifacts
      uses: actions/cache@v4
      with:
        path: |
          build\dist
          build\logs
        key: ${{ runner.os }}-build-artifacts-${{ needs.test-and-quality.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-build-artifacts-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r requirements.txt
        pip install -e .
        
    - name: Verify installation and imports
      run: |
        Write-Host "üîç Verifying Python installation and critical imports..."
        python --version
        python -c "import sys; print(f'Python: {sys.version}')"
        python -c "import PySide6; print(f'PySide6: {PySide6.__version__}')"
        python -c "import pandas; print(f'Pandas: {pandas.__version__}')"
        python -c "import yaml; print('PyYAML: OK')"
        python -c "import requests; print(f'Requests: {requests.__version__}')"
        python -c "import win32com.client; print('Win32com: OK')"
        python -c "import psutil; print(f'psutil: {psutil.__version__}')"
        Write-Host "‚úÖ All critical imports successful"
        
    - name: Verify build assets
      run: |
        Write-Host "üîç Verifying build assets..."
        if (Test-Path "scripts\build\build_windows.py") {
          Write-Host "‚úÖ Windows build script found"
        } else {
          Write-Host "‚ùå Windows build script missing"
          exit 1
        }
        
        if (Test-Path "assets\icons\csc-reach.ico") {
          Write-Host "‚úÖ Windows icon found"
        } else {
          Write-Host "‚ùå Windows icon missing"
          exit 1
        }
        
        if (Test-Path "scripts\build\build_windows.spec") {
          Write-Host "‚úÖ PyInstaller spec found"
        } else {
          Write-Host "‚ùå PyInstaller spec missing"
          exit 1
        }
        
    - name: Build Windows executable
      run: |
        Write-Host "üöÄ Building Windows executable..."
        python scripts\build\build_windows.py
        
    - name: Verify Windows build output
      run: |
        Write-Host "üîç Verifying Windows build output..."
        
        if (Test-Path "build\dist\CSC-Reach\CSC-Reach.exe") {
          Write-Host "‚úÖ Windows executable created successfully"
          $size = (Get-Item "build\dist\CSC-Reach\CSC-Reach.exe").Length / 1MB
          Write-Host "   Size: $([math]::Round($size, 1)) MB"
        } else {
          Write-Host "‚ùå Windows executable not found"
          Write-Host "Build directory contents:"
          if (Test-Path "build") { dir build -Recurse } else { Write-Host "No build directory" }
          exit 1
        }
        
    - name: Create Windows distribution
      run: |
        Write-Host "üì¶ Creating Windows distribution..."
        python scripts\build\create_windows_zip.py
        
        if (Test-Path "build\dist\CSC-Reach-Windows.zip") {
          Write-Host "‚úÖ Windows ZIP created successfully"
          $size = (Get-Item "build\dist\CSC-Reach-Windows.zip").Length / 1MB
          Write-Host "   Size: $([math]::Round($size, 1)) MB"
        } else {
          Write-Host "‚ö†Ô∏è Windows ZIP not created, creating manually..."
          Compress-Archive -Path "build\dist\CSC-Reach\*" -DestinationPath "build\dist\CSC-Reach-Windows.zip"
          Write-Host "‚úÖ Manual ZIP created"
        }
        
    - name: Store and verify Windows artifacts
      run: |
        Write-Host "üîç Storing and verifying Windows artifacts..."
        
        # Store executable
        if (Test-Path "build\dist\CSC-Reach\CSC-Reach.exe") {
          python scripts\build\artifact_manager.py store --path "build\dist\CSC-Reach\CSC-Reach.exe" --platform windows --type executable
        }
        
        # Store distribution ZIP
        if (Test-Path "build\dist\CSC-Reach-Windows.zip") {
          python scripts\build\artifact_manager.py store --path "build\dist\CSC-Reach-Windows.zip" --platform windows --type distribution
        }
        
        # Create build manifest
        python scripts\build\artifact_manager.py manifest
        
        # Run comprehensive verification
        python scripts\build\build_verification.py --all
        
    - name: Upload Windows executable
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-Windows-${{ github.event.inputs.version || github.sha }}
        path: build/dist/CSC-Reach/
        retention-days: 30
        
    - name: Upload Windows ZIP
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-Windows-ZIP-${{ github.event.inputs.version || github.sha }}
        path: build/dist/CSC-Reach-Windows.zip
        retention-days: 30

  # Job 3: Build macOS application
  build-macos:
    needs: test-and-quality
    if: needs.test-and-quality.outputs.should-build == 'true'
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/Library/Caches/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Cache PyInstaller build cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pyinstaller
          build/cache
          build/temp
        key: ${{ runner.os }}-pyinstaller-${{ needs.test-and-quality.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-pyinstaller-
          
    - name: Cache build artifacts
      uses: actions/cache@v4
      with:
        path: |
          build/dist
          build/logs
        key: ${{ runner.os }}-build-artifacts-${{ needs.test-and-quality.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-build-artifacts-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r requirements.txt
        pip install -e .
        
    - name: Verify installation and imports
      run: |
        echo "üîç Verifying Python installation and critical imports..."
        python --version
        python -c "import sys; print(f'Python: {sys.version}')"
        python -c "import PySide6; print(f'PySide6: {PySide6.__version__}')"
        python -c "import pandas; print(f'Pandas: {pandas.__version__}')"
        python -c "import yaml; print('PyYAML: OK')"
        python -c "import requests; print(f'Requests: {requests.__version__}')"
        python -c "import psutil; print(f'psutil: {psutil.__version__}')"
        echo "‚úÖ All critical imports successful"
        
    - name: Verify build assets
      run: |
        echo "üîç Verifying build assets..."
        if [ -f "scripts/build/build_macos.py" ]; then
          echo "‚úÖ macOS build script found"
        else
          echo "‚ùå macOS build script missing"
          exit 1
        fi
        
        if [ -f "assets/icons/csc-reach.icns" ]; then
          echo "‚úÖ macOS icon found"
        elif [ -f "assets/icons/csc-reach.png" ]; then
          echo "‚úÖ macOS icon (PNG) found"
        else
          echo "‚ùå macOS icon missing"
          exit 1
        fi
        
        if [ -f "scripts/build/build_macos.spec" ]; then
          echo "‚úÖ PyInstaller spec found"
        else
          echo "‚ùå PyInstaller spec missing"
          exit 1
        fi
        
    - name: Build macOS application
      run: |
        echo "üöÄ Building macOS application..."
        python scripts/build/build_macos.py
        
    - name: Verify macOS build output
      run: |
        echo "üîç Verifying macOS build output..."
        
        if [ -d "build/dist/CSC-Reach.app" ]; then
          echo "‚úÖ macOS application created successfully"
          size=$(du -sh "build/dist/CSC-Reach.app" | cut -f1)
          echo "   Size: $size"
        else
          echo "‚ùå macOS application not found"
          echo "Build directory contents:"
          if [ -d "build" ]; then
            find build -type f -name "*.app" -o -name "CSC-Reach*" | head -20
          else
            echo "No build directory"
          fi
          exit 1
        fi
        
    - name: Create macOS DMG (if script exists)
      run: |
        if [ -f "scripts/build/create_dmg.py" ]; then
          echo "üì¶ Creating macOS DMG..."
          python scripts/build/create_dmg.py
          
          if [ -f "build/dist/CSC-Reach-macOS.dmg" ]; then
            echo "‚úÖ macOS DMG created successfully"
            size=$(du -sh "build/dist/CSC-Reach-macOS.dmg" | cut -f1)
            echo "   Size: $size"
          else
            echo "‚ö†Ô∏è DMG creation failed, but continuing..."
          fi
        else
          echo "‚ö†Ô∏è DMG creation script not found, skipping..."
        fi
        
    - name: Store and verify macOS artifacts
      run: |
        echo "üîç Storing and verifying macOS artifacts..."
        
        # Store application bundle
        if [ -d "build/dist/CSC-Reach.app" ]; then
          python scripts/build/artifact_manager.py store --path "build/dist/CSC-Reach.app" --platform macos --type application
        fi
        
        # Store DMG if it exists
        if [ -f "build/dist/CSC-Reach-macOS.dmg" ]; then
          python scripts/build/artifact_manager.py store --path "build/dist/CSC-Reach-macOS.dmg" --platform macos --type distribution
        fi
        
        # Create build manifest
        python scripts/build/artifact_manager.py manifest
        
    - name: Upload macOS application
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-macOS-${{ github.event.inputs.version || github.sha }}
        path: build/dist/CSC-Reach.app/
        retention-days: 30
        
    - name: Upload macOS DMG (if exists)
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-macOS-DMG-${{ github.event.inputs.version || github.sha }}
        path: build/dist/*.dmg
        retention-days: 30
        if-no-files-found: warn

  # Job 4: Create release (only on tags or manual release)
  create-release:
    needs: [build-windows, build-macos]
    if: startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type == 'production')
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts
        
    - name: Prepare release assets
      run: |
        echo "üì¶ Preparing release assets..."
        mkdir -p ./release-assets
        
        # Find and copy Windows ZIP
        find ./artifacts -name "*.zip" -type f -exec cp {} ./release-assets/ \;
        
        # Find and copy macOS DMG
        find ./artifacts -name "*.dmg" -type f -exec cp {} ./release-assets/ \;
        
        # List prepared assets
        echo "Release assets prepared:"
        ls -la ./release-assets/
        
    - name: Generate release notes
      id: release-notes
      run: |
        echo "üìù Generating release notes..."
        
        # Get version from tag or input
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION="${{ github.event.inputs.version || 'latest' }}"
        fi
        
        # Create release notes
        cat > release-notes.md << EOF
        # CSC-Reach $VERSION
        
        ## üöÄ What's New
        
        This release includes the latest improvements and bug fixes for CSC-Reach.
        
        ## üì¶ Downloads
        
        - **Windows**: Download \`CSC-Reach-Windows.zip\` and extract to your desired location
        - **macOS**: Download \`CSC-Reach-macOS.dmg\` and drag the app to your Applications folder
        
        ## üîß System Requirements
        
        ### Windows
        - Windows 10 or later
        - Microsoft Outlook installed and configured
        - 4GB RAM minimum
        
        ### macOS
        - macOS 10.14 or later
        - Microsoft Outlook for Mac installed and configured
        - 4GB RAM minimum
        
        ## üìã Installation Instructions
        
        Detailed installation guides are available in the repository documentation.
        
        ## üêõ Bug Reports
        
        If you encounter any issues, please report them in the GitHub Issues section.
        
        ---
        
        **Build Information:**
        - Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        - Commit: ${{ github.sha }}
        - Workflow: ${{ github.run_id }}
        EOF
        
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.release-notes.outputs.VERSION }}
        name: CSC-Reach ${{ steps.release-notes.outputs.VERSION }}
        body_path: release-notes.md
        files: ./release-assets/*
        draft: false
        prerelease: ${{ github.event.inputs.release_type != 'production' }}
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 5: Comprehensive build verification and smoke testing
  test-builds:
    needs: [build-windows, build-macos]
    strategy:
      matrix:
        os: [windows-latest, macos-latest]
        include:
          - os: windows-latest
            artifact-name: CSC-Reach-Windows
            executable: CSC-Reach.exe
            min-size-mb: 10
          - os: macos-latest
            artifact-name: CSC-Reach-macOS
            executable: CSC-Reach.app
            min-size-mb: 150
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Download built application
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}-${{ github.event.inputs.version || github.sha }}
        path: ./test-app/
        
    - name: Comprehensive Windows application testing
      if: matrix.os == 'windows-latest'
      run: |
        Write-Host "üß™ Comprehensive Windows application testing..."
        cd test-app
        
        # Basic file existence and format checks
        if (Test-Path "CSC-Reach.exe") {
          Write-Host "‚úÖ Executable found"
          $fileInfo = Get-Item "CSC-Reach.exe"
          $sizeMB = [math]::Round($fileInfo.Length / 1MB, 1)
          Write-Host "   Size: $sizeMB MB"
          Write-Host "   Created: $($fileInfo.CreationTime)"
          
          # Check minimum size requirement
          if ($sizeMB -lt ${{ matrix.min-size-mb }}) {
            Write-Host "‚ùå Executable too small ($sizeMB MB < ${{ matrix.min-size-mb }} MB)"
            exit 1
          } else {
            Write-Host "‚úÖ Size check passed ($sizeMB MB >= ${{ matrix.min-size-mb }} MB)"
          }
          
          # Test that it's a valid PE file
          $signature = Get-Content "CSC-Reach.exe" -Encoding Byte -TotalCount 2
          if ($signature[0] -eq 77 -and $signature[1] -eq 90) {
            Write-Host "‚úÖ Valid PE executable format"
          } else {
            Write-Host "‚ùå Invalid executable format"
            exit 1
          }
          
          # Check for required DLLs and dependencies
          Write-Host "üîç Checking for critical dependencies..."
          $requiredFiles = @(
            "config",
            "assets",
            "multichannel_messaging"
          )
          
          foreach ($file in $requiredFiles) {
            if (Test-Path $file) {
              Write-Host "‚úÖ Required dependency found: $file"
            } else {
              Write-Host "‚ö†Ô∏è Optional dependency missing: $file"
            }
          }
          
          # Smoke test - try to run with --help flag
          Write-Host "üî• Running smoke test..."
          try {
            $process = Start-Process -FilePath ".\CSC-Reach.exe" -ArgumentList "--help" -Wait -PassThru -WindowStyle Hidden -RedirectStandardOutput "smoke_test_output.txt" -RedirectStandardError "smoke_test_error.txt"
            
            if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 1) {
              Write-Host "‚úÖ Smoke test passed (exit code: $($process.ExitCode))"
              if (Test-Path "smoke_test_output.txt") {
                $output = Get-Content "smoke_test_output.txt" -Raw
                if ($output -and $output.Length -gt 0) {
                  Write-Host "   Output preview: $($output.Substring(0, [Math]::Min(100, $output.Length)))"
                }
              }
            } else {
              Write-Host "‚ö†Ô∏è Smoke test completed with exit code: $($process.ExitCode)"
              if (Test-Path "smoke_test_error.txt") {
                $error = Get-Content "smoke_test_error.txt" -Raw
                if ($error -and $error.Length -gt 0) {
                  Write-Host "   Error preview: $($error.Substring(0, [Math]::Min(200, $error.Length)))"
                }
              }
            }
          } catch {
            Write-Host "‚ö†Ô∏è Smoke test failed to run: $($_.Exception.Message)"
          }
          
          # Check file permissions
          $acl = Get-Acl "CSC-Reach.exe"
          Write-Host "‚úÖ File permissions check completed"
          
        } else {
          Write-Host "‚ùå Executable not found"
          Write-Host "Available files:"
          dir
          exit 1
        }
        
    - name: Comprehensive macOS application testing
      if: matrix.os == 'macos-latest'
      run: |
        echo "üß™ Comprehensive macOS application testing..."
        cd test-app
        
        if [ -d "CSC-Reach.app" ]; then
          echo "‚úÖ Application bundle found"
          
          # Get and check size
          size_bytes=$(du -s "CSC-Reach.app" | cut -f1)
          size_mb=$((size_bytes / 1024))
          size_human=$(du -sh "CSC-Reach.app" | cut -f1)
          echo "   Size: $size_human ($size_mb MB)"
          
          # Check minimum size requirement
          if [ $size_mb -lt ${{ matrix.min-size-mb }} ]; then
            echo "‚ùå Application too small ($size_mb MB < ${{ matrix.min-size-mb }} MB)"
            exit 1
          else
            echo "‚úÖ Size check passed ($size_mb MB >= ${{ matrix.min-size-mb }} MB)"
          fi
          
          # Check if it's a valid app bundle structure
          if [ -f "CSC-Reach.app/Contents/Info.plist" ]; then
            echo "‚úÖ Valid application bundle structure"
            
            # Verify Info.plist content
            if command -v plutil >/dev/null 2>&1; then
              if plutil -lint "CSC-Reach.app/Contents/Info.plist" >/dev/null 2>&1; then
                echo "‚úÖ Info.plist is valid"
                
                # Extract key information
                bundle_id=$(plutil -extract CFBundleIdentifier raw "CSC-Reach.app/Contents/Info.plist" 2>/dev/null || echo "N/A")
                bundle_version=$(plutil -extract CFBundleShortVersionString raw "CSC-Reach.app/Contents/Info.plist" 2>/dev/null || echo "N/A")
                echo "   Bundle ID: $bundle_id"
                echo "   Version: $bundle_version"
              else
                echo "‚ö†Ô∏è Info.plist format issues detected"
              fi
            fi
            
            # Check executable
            if [ -f "CSC-Reach.app/Contents/MacOS/CSC-Reach" ]; then
              echo "‚úÖ Main executable found in bundle"
              
              # Check executable permissions
              if [ -x "CSC-Reach.app/Contents/MacOS/CSC-Reach" ]; then
                echo "‚úÖ Executable has proper permissions"
              else
                echo "‚ùå Executable lacks execute permissions"
                exit 1
              fi
              
              # Check executable format
              if file "CSC-Reach.app/Contents/MacOS/CSC-Reach" | grep -q "Mach-O"; then
                echo "‚úÖ Valid Mach-O executable format"
              else
                echo "‚ùå Invalid executable format"
                exit 1
              fi
              
            else
              echo "‚ùå Main executable not found in bundle"
              exit 1
            fi
            
            # Check for required resources
            echo "üîç Checking for critical resources..."
            required_dirs=(
              "Contents/Resources"
              "Contents/Frameworks"
            )
            
            for dir in "${required_dirs[@]}"; do
              if [ -d "CSC-Reach.app/$dir" ]; then
                echo "‚úÖ Required directory found: $dir"
              else
                echo "‚ö†Ô∏è Optional directory missing: $dir"
              fi
            done
            
            # Smoke test - try to run with --help flag
            echo "üî• Running smoke test..."
            timeout 30s "CSC-Reach.app/Contents/MacOS/CSC-Reach" --help > smoke_test_output.txt 2> smoke_test_error.txt || smoke_exit_code=$?
            
            if [ ${smoke_exit_code:-0} -eq 0 ] || [ ${smoke_exit_code:-0} -eq 1 ] || [ ${smoke_exit_code:-0} -eq 124 ]; then
              echo "‚úÖ Smoke test completed (exit code: ${smoke_exit_code:-0})"
              if [ -s smoke_test_output.txt ]; then
                echo "   Output preview: $(head -c 100 smoke_test_output.txt)"
              fi
            else
              echo "‚ö†Ô∏è Smoke test completed with exit code: ${smoke_exit_code:-0}"
              if [ -s smoke_test_error.txt ]; then
                echo "   Error preview: $(head -c 200 smoke_test_error.txt)"
              fi
            fi
            
            # Check code signing (if available)
            if command -v codesign >/dev/null 2>&1; then
              echo "üîç Checking code signing..."
              if codesign -v "CSC-Reach.app" 2>/dev/null; then
                echo "‚úÖ Code signature is valid"
              else
                echo "‚ö†Ô∏è No valid code signature (expected for unsigned builds)"
              fi
            fi
            
          else
            echo "‚ùå Invalid application bundle structure"
            exit 1
          fi
        else
          echo "‚ùå Application bundle not found"
          echo "Available files:"
          ls -la
          exit 1
        fi
        
    - name: Generate test report
      if: always()
      run: |
        echo "üìä Build Verification Report" > test_report.txt
        echo "=========================" >> test_report.txt
        echo "Platform: ${{ matrix.os }}" >> test_report.txt
        echo "Artifact: ${{ matrix.artifact-name }}" >> test_report.txt
        echo "Test Date: $(date)" >> test_report.txt
        echo "" >> test_report.txt
        
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          if [ -f "smoke_test_output.txt" ]; then
            echo "Smoke Test Output:" >> test_report.txt
            cat smoke_test_output.txt >> test_report.txt
          fi
          if [ -f "smoke_test_error.txt" ]; then
            echo "Smoke Test Errors:" >> test_report.txt
            cat smoke_test_error.txt >> test_report.txt
          fi
        else
          if [ -f "smoke_test_output.txt" ]; then
            echo "Smoke Test Output:" >> test_report.txt
            cat smoke_test_output.txt >> test_report.txt
          fi
          if [ -f "smoke_test_error.txt" ]; then
            echo "Smoke Test Errors:" >> test_report.txt
            cat smoke_test_error.txt >> test_report.txt
          fi
        fi
        
    - name: Upload test report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-report-${{ matrix.os }}-${{ github.event.inputs.version || github.sha }}
        path: test-app/test_report.txt
        retention-days: 30
        if-no-files-found: warn

  # Job 6: Deployment notification (optional)
  notify-completion:
    needs: [test-builds, create-release]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Build Summary
      run: |
        echo "üéâ Cross-platform build workflow completed!"
        echo ""
        echo "üìä Build Results:"
        echo "- Windows Build: ${{ needs.build-windows.result }}"
        echo "- macOS Build: ${{ needs.build-macos.result }}"
        echo "- Tests: ${{ needs.test-builds.result }}"
        echo "- Release: ${{ needs.create-release.result }}"
        echo ""
        echo "üîó Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        if [[ "${{ needs.build-windows.result }}" == "success" && "${{ needs.build-macos.result }}" == "success" ]]; then
          echo "‚úÖ All builds completed successfully!"
        else
          echo "‚ö†Ô∏è Some builds may have failed. Check the logs above."
        fi