name: Build Windows Executable

permissions:
  contents: write
  actions: read

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version tag (e.g., v1.0.0)"
        required: false
        default: "latest"
  push:
    branches: [main]
    paths:
      - "pyproject.toml"
    tags:
      - "v*"
  pull_request:
    branches: [main]

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version-changed: ${{ steps.version-check.outputs.changed }}
      new-version: ${{ steps.version-check.outputs.version }}
      should-release: ${{ steps.version-check.outputs.should-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check version change
        id: version-check
        run: |
          # Get current version from pyproject.toml
          CURRENT_VERSION=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
          echo "Current version: $CURRENT_VERSION"

          # Get latest tag
          LATEST_TAG=$(git tag --sort=-version:refname | head -1 | sed 's/^v//' || echo "0.0.0")
          echo "Latest tag version: $LATEST_TAG"

          # Check if this is a manual trigger or tag push
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "Manual trigger or tag push - proceeding with build"
          elif [[ "$CURRENT_VERSION" != "$LATEST_TAG" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "Version changed from $LATEST_TAG to $CURRENT_VERSION"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "No version change detected"
          fi

  build-windows:
    needs: check-version
    if: needs.check-version.outputs.version-changed == 'true' || github.event_name == 'pull_request'
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug - List repository contents
        run: |
          Write-Host "Repository root contents:"
          dir
          Write-Host "`nScripts directory:"
          if (Test-Path "scripts") { dir scripts } else { Write-Host "scripts directory not found" }
          Write-Host "`nBuild scripts directory:"
          if (Test-Path "scripts\build") { dir scripts\build } else { Write-Host "scripts\build directory not found" }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Verify Python installation
        run: |
          python --version
          pip --version

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e ".[dev]"

      - name: Verify PyInstaller installation
        run: |
          python -m PyInstaller --version

      - name: Test Python imports
        run: |
          Write-Host "Testing critical imports..."
          python -c "import sys; print(f'Python: {sys.version}')"
          python -c "import PySide6; print(f'PySide6: {PySide6.__version__}')"
          python -c "import pandas; print(f'Pandas: {pandas.__version__}')"
          python -c "import yaml; print('PyYAML: OK')"
          python -c "import requests; print(f'Requests: {requests.__version__}')"
          python -c "import win32com.client; print('Win32com: OK')" 
          Write-Host "‚úÖ All critical imports successful"

      - name: Check build script and assets exist
        run: |
          if (Test-Path "scripts\build\build_windows.py") {
            Write-Host "‚úÖ build_windows.py found"
          } else {
            Write-Host "‚ùå build_windows.py not found"
            Write-Host "Available files in scripts\build:"
            if (Test-Path "scripts\build") { dir scripts\build } else { Write-Host "scripts\build directory not found" }
            exit 1
          }

          if (Test-Path "assets\icons\csc-reach.ico") {
            Write-Host "‚úÖ Icon file found"
          } else {
            Write-Host "‚ùå Icon file not found at assets\icons\csc-reach.ico"
            Write-Host "Available icon files:"
            if (Test-Path "assets\icons") { dir assets\icons } else { Write-Host "assets\icons directory not found" }
          }

          if (Test-Path "scripts\build\build_windows.spec") {
            Write-Host "‚úÖ PyInstaller spec file found"
          } else {
            Write-Host "‚ùå PyInstaller spec file not found"
          }

      - name: Build Windows executable
        run: |
          Write-Host "üöÄ Starting Windows build process..."
          python scripts\build\build_windows.py
        continue-on-error: false

      - name: Check build output
        run: |
          Write-Host "Build directory contents:"
          if (Test-Path "build") { dir build -Recurse } else { Write-Host "build directory not found" }

          # Check for build logs
          if (Test-Path "build\logs") {
            Write-Host "`nBuild logs:"
            dir build\logs
            if (Test-Path "build\logs\build_windows_error.log") {
              Write-Host "`n‚ùå Error log found:"
              Get-Content "build\logs\build_windows_error.log" | Select-Object -Last 50
            }
            if (Test-Path "build\logs\build_windows.log") {
              Write-Host "`nüìã Build log (last 20 lines):"
              Get-Content "build\logs\build_windows.log" | Select-Object -Last 20
            }
          }

          if (Test-Path "build\dist\CSC-Reach\CSC-Reach.exe") {
            Write-Host "‚úÖ Windows executable created successfully"
            $size = (Get-Item "build\dist\CSC-Reach\CSC-Reach.exe").Length / 1MB
            Write-Host "   Size: $([math]::Round($size, 1)) MB"
          } else {
            Write-Host "‚ùå Windows executable not found"
            Write-Host "Expected location: build\dist\CSC-Reach\CSC-Reach.exe"
            
            # Show what was actually created
            Write-Host "`nActual build output:"
            if (Test-Path "build\dist") { 
              dir build\dist -Recurse 
            } else { 
              Write-Host "No build\dist directory found" 
            }
            exit 1
          }

      - name: Create Windows ZIP distribution
        run: |
          $version = "${{ needs.check-version.outputs.new-version || github.event.inputs.version || 'latest' }}"
          $zipName = "CSC-Reach-Windows-$version.zip"

          Write-Host "Creating ZIP: $zipName"
          Compress-Archive -Path "build\dist\CSC-Reach\*" -DestinationPath "build\dist\$zipName" -Force
          Write-Host "‚úÖ ZIP created: $zipName"

          # Verify ZIP contents
          Write-Host "ZIP contents:"
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zip = [System.IO.Compression.ZipFile]::OpenRead("build\dist\$zipName")
          $zip.Entries | ForEach-Object { Write-Host "  $($_.FullName)" }
          $zip.Dispose()

      - name: Upload Windows ZIP
        uses: actions/upload-artifact@v4
        with:
          name: CSC-Reach-Windows-${{ needs.check-version.outputs.new-version || github.event.inputs.version || 'latest' }}
          path: build/dist/CSC-Reach-Windows-*.zip
          retention-days: 30

      - name: Create Release
        if: needs.check-version.outputs.should-release == 'true' && github.event_name != 'pull_request'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-version.outputs.new-version }}
          name: CSC-Reach ${{ needs.check-version.outputs.new-version }}
          files: |
            build/dist/CSC-Reach-Windows-*.zip
          draft: false
          prerelease: false
          generate_release_notes: true
          body: |
            ## CSC-Reach ${{ needs.check-version.outputs.new-version }}

            ### Windows Release
            - **CSC-Reach-Windows-${{ needs.check-version.outputs.new-version }}.zip**: Complete Windows application package

            ### Installation
            1. Download the ZIP file
            2. Extract to your desired location
            3. Run `CSC-Reach.exe`

            ### What's Changed
            ${{ github.event.head_commit.message || 'Automated release from version update' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-windows-build:
    needs: [check-version, build-windows]
    if: needs.check-version.outputs.version-changed == 'true' || github.event_name == 'pull_request'
    runs-on: windows-latest

    steps:
      - name: Download Windows ZIP
        uses: actions/download-artifact@v4
        with:
          name: CSC-Reach-Windows-${{ needs.check-version.outputs.new-version || github.event.inputs.version || 'latest' }}
          path: ./test-build/

      - name: Extract and test executable
        run: |
          cd test-build
          Write-Host "Downloaded artifacts:"
          dir

          # Find and extract the ZIP file
          $zipFile = Get-ChildItem -Name "CSC-Reach-Windows-*.zip" | Select-Object -First 1
          if ($zipFile) {
            Write-Host "Extracting: $zipFile"
            Expand-Archive -Path $zipFile -DestinationPath "./extracted/" -Force
            cd extracted
          } else {
            Write-Host "No ZIP file found, checking for direct executable"
          }

          Write-Host "Extracted contents:"
          dir

          if (Test-Path "CSC-Reach.exe") {
            Write-Host "‚úÖ Executable found"
            # Test that the executable exists and is a valid PE file
            $fileInfo = Get-Item "CSC-Reach.exe"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 1)) MB"
            Write-Host "   Created: $($fileInfo.CreationTime)"
            
            # Quick validation that it's a valid Windows executable
            try {
              $bytes = [System.IO.File]::ReadAllBytes("CSC-Reach.exe")
              if ($bytes[0] -eq 77 -and $bytes[1] -eq 90) {  # MZ header
                Write-Host "‚úÖ Valid Windows executable format"
              } else {
                Write-Host "‚ùå Invalid executable format"
                exit 1
              }
            } catch {
              Write-Host "‚ö†Ô∏è Could not validate executable format, but file exists"
            }
          } else {
            Write-Host "‚ùå Executable not found"
            Write-Host "Available files:"
            dir -Recurse
            exit 1
          }
